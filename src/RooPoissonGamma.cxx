/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 
#include <iostream> 

#include "RooPoissonGamma.h" 
#include "Riostream.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include "RooRandom.h"
#include <math.h> 
#include "TMath.h" 
#include "Math/ProbFuncMathCore.h"

ClassImp(RooPoissonGamma) 

using namespace std;

RooPoissonGamma::RooPoissonGamma(const char *name, const char *title, 
                        RooAbsReal& x, 
                        const RooArgList& meanList, 
                        const RooArgList& errorList,
                       Bool_t noRounding) :
    RooAbsPdf(name,title),
    _x("x","Observable",this,x),
    _meanList("meanList","List of means for sources",this),
    _errorList("errorList","List of sum squared errors for sources",this),
    _gslRan(new ROOT::Math::Random<ROOT::Math::GSLRngMT>()),
    _noRounding(noRounding),
    _protectNegative(false)
{ 
    _meanIter = _meanList.createIterator();
    _errorIter = _errorList.createIterator();

    TIterator* meanIter = meanList.createIterator() ;
    RooAbsArg* mean ;
    while((mean = (RooAbsArg*)meanIter->Next())) {
        if (!dynamic_cast<RooAbsReal*>(mean)) {
            cout << "RooPolynomial::ctor(" << GetName() << ") ERROR: meanficient " << mean->GetName() 
                 << " is not of type RooAbsReal" << endl ;
            assert(0) ;
        }
        _meanList.add(*mean) ;
    }
    delete meanIter ;

   TIterator* errorIter = errorList.createIterator() ;
    RooAbsArg* error ;
    while((error = (RooAbsArg*)errorIter->Next())) {
        if (!dynamic_cast<RooAbsReal*>(error)) {
            cout << "RooPolynomial::ctor(" << GetName() << ") ERROR: errorficient " << error->GetName() 
                 << " is not of type RooAbsReal" << endl ;
            assert(0) ;
        }
        _errorList.add(*error) ;
    }
    delete errorIter ;
 
 } 



 RooPoissonGamma::RooPoissonGamma(const RooPoissonGamma& other, const char* name) :  
 RooAbsPdf(other,name), 
 _x("x",this,other._x), 
 _meanList("meanList",this,other._meanList), 
 _errorList("errorList",this,other._errorList),
 _gslRan(other._gslRan)
 { 
   _meanIter = _meanList.createIterator();
   _errorIter = _errorList.createIterator();
 } 



 Double_t RooPoissonGamma::evaluate() const 
 { 
  int Di = floor(_x);  

  vector<double> A;
  vector<double> dA;
  
  if(_protectNegative && _meanList.first()<0) 
    return 1e-3;
  _meanIter->Reset();
  RooAbsReal* mean ;
  const RooArgSet* nset1 = _meanList.nset() ;
  while((mean=(RooAbsReal*)_meanIter->Next())) {
  A.push_back(mean->getVal(nset1));
//  cout << "Mean: " << mean->getVal(nset1) << endl;
  }

  _errorIter->Reset();
  RooAbsReal* error ;
  const RooArgSet* nset2 = _errorList.nset() ;
  while(  error=(RooAbsReal*)_errorIter->Next() ) {
//  cout << "Error: " << error->getVal(nset2) << endl;
  dA.push_back(error->getVal(nset2));
  }

    const int MAXSRC = 8; // Maximum number of sources
    const int MAXBUF = 50000; // Maximum count per bin
    
    double s [MAXSRC];
    double f [MAXSRC];
    double x [MAXSRC];
    long double c[MAXSRC][MAXBUF];
    
    int N = A.size(); // Number of sources (N)
    
    // Check inputs
    if ( A.size() != dA.size() )
    {
        std::cout << "**Error - poissongamma - mis-match in number of sources"
        << endl
        << "size(dA): " << dA.size() << " differs from size(A) = " << A.size()
        << std::endl;
        exit(0);
    }
    
    
    // first do zero...      
    for (int j = 0; j < N; ++j)
    {
        s[j] = A[j];
        f[j] = 1.;
        x[j] = 1.;
        
        if ( dA[j] > 0 )
        {
        f[j] = A[j] / (dA[j]*dA[j]);
        } else {
        f[j] = 10000;
        }


        // This 'if' statement makes sure that we don't overwhelm the TMath::Gamma function.
        // In the case that we would overflow this function, we set the scale parameter 
        // to the highest computable scale.
        // This is conservative in the sense that we the prior on the total 
        // count is more smeared out than it would be if we could calculate the 
        // exact value -- it gives you something very close to a poisson with
        // no prior on the mean, but using an exact poisson would be non-conservative
        // as it assumes we know the "true mean" exactly.  This puts a small as possible error on the true mean.  
        // Another option would be to just fail the function and return an error. 

        if(f[j]*s[j] + Di + 0.5 > 140) {
           f[j] = (139.5 - Di)/s[j];
        }

//        if( s[j] * f[j] > 100) f[j] = 100 / s[j];

        // For bins with zero bin content
        // c[j][0] = 0;
        c[j][0] = 0;
        if ( f[j] > 0. )
        {
        x[j] *= f[j];
        s[j] *= f[j];
        }
        else 
        {
        x[j] = 100000.;
        s[j] = 0.;                    
        }
        
        c[j][0] = exp(  (s[j]+0.5) * log(x[j])  - (s[j]+0.5) * log(x[j]+1.) );
        
//        cout << "TMath::Gamma(" << s[j] + Di + 0.5 << "): " << TMath::Gamma(s[j] + Di + 0.5) << endl;

    }
    
    
    // ...then 1 to D
    if ( Di > 0 )
    {
        for (int k = 1; k < Di+1; ++k)
        for (int j = 0; j < N; ++j)
        {
            c[j][k] = 
            exp(  (s[j]+0.5) * log(x[j])  - (k + s[j]+0.5) * log(x[j]+1) ) *
            TMath::Gamma(s[j] + k + 0.5) / 
            (  TMath::Gamma(k+1) * TMath::Gamma( s[j] + 0.5 )  ) ;
            if(x[j] == 0) c[j][k] = 0;
        }
    }
    
    // compute sum
    double sum = 0.0;
    switch (N)
    {
        case 1:
            sum += c[0][Di];
            break;
    
        case 2:
            for (int j = 0; j < Di+1; ++j){
            sum += 
                c[0][j] *
                c[1][Di-j];
            }        
        break;
        
        case 3:
            for (int j = 0; j < Di+1; ++j)
            for (int k = 0; k < Di+1-j; ++k)
            sum += 
                c[0][j] *
                c[1][k] *
                c[2][Di-j-k];
        break;
        
        case 4:
            for (int j = 0; j < Di+1; ++j)
            for (int k = 0; k < Di+1-j; ++k)
            for (int l = 0; l < Di+1-j-k; ++l)
            sum += 
                c[0][j] *
                c[1][k] *
                c[2][l] *
                c[3][Di-j-k-l];
        break;
        
        case 5:
            for (int j = 0; j < Di+1; ++j)
            for (int k = 0; k < Di+1-j; ++k)
            for (int l = 0; l < Di+1-j-k; ++l)
            for (int m = 0; m < Di+1-j-k-l; ++m)
            sum += 
                c[0][j] *
                c[1][k] *
                c[2][l] *
                c[3][m] *
                c[4][Di-j-k-l-m];
        break;
        
        case 6:
            for (int j = 0; j < Di+1; ++j)
            for (int k = 0; k < Di+1-j; ++k)
            for (int l = 0; l < Di+1-j-k; ++l)
            for (int m = 0; m < Di+1-j-k-l; ++m)
            for (int n = 0; n < Di+1-j-k-l-m; ++n)
            sum += 
                c[0][j] *
                c[1][k] *
                c[2][l] *
                c[3][m] *
                c[4][n] *
                c[5][Di-j-k-l-m-n];
        break;
        
        case 7:
            for (int j = 0; j < Di+1; ++j)
            for (int k = 0; k < Di+1-j; ++k)
            for (int l = 0; l < Di+1-j-k; ++l)
            for (int m = 0; m < Di+1-j-k-l; ++m)
            for (int n = 0; n < Di+1-j-k-l-m; ++n)
            for (int jj = 0; jj < Di+1-j-k-l-m-n; ++jj)
            sum += 
                c[0][j] *
                c[1][k] *
                c[2][l] *
                c[3][m] *
                c[4][n] *
                c[5][jj] *
                c[6][Di-j-k-l-m-n-jj];
        break;
        
        case 8:
            for (int j = 0; j < Di+1; ++j)
            for (int k = 0; k < Di+1-j; ++k)
            for (int l = 0; l < Di+1-j-k; ++l)
            for (int m = 0; m < Di+1-j-k-l; ++m)
            for (int n = 0; n < Di+1-j-k-l-m; ++n)
            for (int jj = 0; jj < Di+1-j-k-l-m-n; ++jj)
            for (int kk = 0; kk < Di+1-j-k-l-m-n-jj; ++kk)
                sum += 
                c[0][j] *
                c[1][k] *
                c[2][l] *
                c[3][m] *
                c[4][n] *
                c[5][jj] *
                c[6][kk] *
                c[7][Di-j-k-l-m-n-jj-kk];
            break;
    };

//  cout << "PoissonGamma(" << _x  << ") = " <<  sum << endl;
  return sum ;
 }
 

//_____________________________________________________________________________
Int_t RooPoissonGamma::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const
{
  // Advertise internal generator in x

  if (matchArgs(directVars,generateVars,_x)) return 1 ;  
  return 0 ;
}
 
 

//_____________________________________________________________________________
void RooPoissonGamma::generateEvent(Int_t code)
{
  // Implement internal generator using TRandom::Poisson 
  assert(code==1) ;
  
  double total = 0.;  

  const int MAXSRC = 8; // Maximum number of sources
  const int MAXBUF = 50000; // Maximum count per bin

  double s [MAXSRC];
  double f [MAXSRC];
  double x [MAXSRC];

  vector<double> A;
  vector<double> dA;
  
  _meanIter->Reset();
  RooAbsReal* mean ;
  const RooArgSet* nset1 = _meanList.nset() ;
  while((mean=(RooAbsReal*)_meanIter->Next())) {
  A.push_back(mean->getVal(nset1));
//  cout << "Mean: " << mean->getVal(nset1) << endl;
  }

  _errorIter->Reset();
  RooAbsReal* error ;
  const RooArgSet* nset2 = _errorList.nset() ;
  while(  error=(RooAbsReal*)_errorIter->Next() ) {
//  cout << "Error: " << error->getVal(nset2) << endl;
  dA.push_back(error->getVal(nset2));
  }

  int N = A.size(); // Number of sources (N)




  // first do zero...      
  for (int j = 0; j < N; ++j)
  {
    s[j] = A[j];
    f[j] = 1.;
    x[j] = 1.;
    
    if ( dA[j] > 0 )
    {
    f[j] = A[j] / (dA[j]*dA[j]);
    } else {
    f[j] = 10000;
    }

    if ( f[j] > 0 )
    {
        x[j] *= f[j];
        s[j] *= f[j];
    }
    total += RooRandom::randomGenerator()->Poisson(_gslRan->Gamma(s[j]+0.5, 1.0/f[j])); 
  }

  _x = total;
  return;


}